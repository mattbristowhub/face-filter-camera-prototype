<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Face Filter Camera - Preview Only</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            /* Safari dynamic viewport support */
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
        }
        
        /* Safari interface visibility states */
        body.safari-interface-visible .controls {
            bottom: 45px !important;
            padding-bottom: calc(45px + env(safe-area-inset-bottom, 35px)) !important;
        }
        
        /* Safari tab bar specific adjustments */
        body.safari-tab-bar-visible .controls {
            bottom: 55px !important;
            padding-bottom: calc(55px + env(safe-area-inset-bottom, 40px)) !important;
            margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 20px) !important;
        }
        
        /* Fallback positioning for unsupported browsers */
        @supports not (padding: env(safe-area-inset-bottom)) {
            .controls {
                bottom: 40px !important;
                padding-bottom: 40px !important;
            }
            
            @media (max-width: 768px) {
                .controls {
                    bottom: 50px !important;
                    padding-bottom: 50px !important;
                }
            }
        }
        
        /* Additional Safari-specific enhancements */
        @supports (-webkit-touch-callout: none) {
            /* Prevent Safari from interfering with controls */
            .controls {
                -webkit-transform: translateX(-50%);
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                will-change: transform;
            }
            
            /* Enhanced scrolling for filter selector */
            .filter-selector {
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .filter-selector::-webkit-scrollbar {
                display: none;
            }
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            position: relative;
        }
        
        .camera-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
        }
        
        #video {
            width: 100%;
            height: auto;
            transform: scaleX(-1);
            display: block;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        }
        
        .controls {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            align-items: center;
            background: rgba(0,0,0,0.5);
            padding: 15px 25px;
            padding-bottom: calc(25px + env(safe-area-inset-bottom, 20px));
            border-radius: 50px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            max-width: 90vw;
            overflow-x: auto;
            /* Safari-specific bottom spacing for tab bar */
            margin-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        /* Safari mobile specific adjustments */
        @supports (-webkit-touch-callout: none) {
            .controls {
                bottom: 35px;
                padding-bottom: calc(35px + env(safe-area-inset-bottom, 25px));
                /* Additional Safari tab bar clearance */
                margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
            }
        }
        
        .capture-btn {
            width: 70px;
            height: 70px;
            min-width: 70px;
            min-height: 70px;
            border-radius: 50%;
            background: #fff;
            border: 5px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            touch-action: manipulation;
            /* Enhanced iOS Safari touch support */
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Ensure capture button meets 44px minimum touch target */
        .capture-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 74px; /* Slightly larger than button for easier touch */
            height: 74px;
            transform: translate(-50%, -50%);
            z-index: -1;
        }
        
        .capture-btn:hover {
            transform: scale(1.1);
        }
        
        .capture-btn:active {
            transform: scale(0.95);
        }
        
        .filter-selector {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .filter-btn {
            width: 50px;
            height: 50px;
            min-width: 50px;
            min-height: 50px;
            border-radius: 50%;
            border: 2px solid #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
            background: rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            flex-shrink: 0;
            /* Enhanced iOS Safari touch support */
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            /* Minimum 44px touch target compliance */
            position: relative;
        }
        
        /* Ensure minimum touch target size on all devices */
        .filter-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 44px;
            height: 44px;
            min-width: 44px;
            min-height: 44px;
            transform: translate(-50%, -50%);
            z-index: -1;
        }
        
        .filter-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .filter-btn.active {
            background: rgba(255,255,255,0.3);
            border-color: #4CAF50;
        }
        
        /* Mobile-specific improvements with enhanced Safari support */
        @media (max-width: 768px) {
            .controls {
                gap: 12px;
                padding: 12px 20px;
                bottom: 30px; /* Increased from 15px for Safari tab bar */
                padding-bottom: calc(30px + env(safe-area-inset-bottom, 25px));
            }
            
            .filter-btn {
                width: 48px;
                height: 48px;
                min-width: 48px;
                min-height: 48px;
                font-size: 18px;
                /* Enhanced touch targets for Safari */
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(255,255,255,0.2);
            }
            
            .capture-btn {
                width: 64px;
                height: 64px;
                min-width: 64px;
                min-height: 64px;
                /* Enhanced touch targets for Safari */
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(255,255,255,0.1);
            }
        }
        
        /* iOS Safari specific mobile adjustments */
        @supports (-webkit-touch-callout: none) {
            @media (max-width: 768px) {
                .controls {
                    bottom: 40px; /* Extra clearance for Safari tab bar */
                    padding-bottom: calc(40px + env(safe-area-inset-bottom, 30px));
                    margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 15px);
                }
            }
        }
        
        /* Tablet-specific improvements */
        @media (min-width: 769px) and (max-width: 1024px) {
            .controls {
                gap: 18px;
                padding: 18px 30px;
            }
            
            .filter-btn {
                width: 60px;
                height: 60px;
                min-width: 60px;
                min-height: 60px;
                font-size: 24px;
            }
            
            .capture-btn {
                width: 80px;
                height: 80px;
                min-width: 80px;
                min-height: 80px;
            }
        }
        
        .status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            font-size: 14px;
        }
        
        .preview-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .preview-flash.active {
            opacity: 1;
        }
        
        #capturedImage {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 150px;
            height: auto;
            border: 3px solid #fff;
            border-radius: 10px;
            transform: scaleX(-1);
            opacity: 0;
            transition: opacity 0.5s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        #capturedImage.show {
            opacity: 1;
        }
        
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.9);
            padding: 15px;
            border-radius: 10px;
            max-width: 250px;
            font-size: 14px;
            line-height: 1.5;
            z-index: 10;
        }
        
        /* Mobile responsive improvements */
        @media (max-width: 768px) {
            .info {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                font-size: 12px;
                padding: 10px;
            }
            
            .status {
                top: 10px;
                font-size: 12px;
                padding: 8px 16px;
            }
            
            .camera-container {
                margin: 10px;
                max-width: calc(100vw - 20px);
            }
            
            #capturedImage {
                width: 100px;
                bottom: 120px;
                right: 10px;
            }
        }
        
        /* Tablet responsive improvements */
        @media (min-width: 769px) and (max-width: 1024px) {
            .info {
                max-width: 300px;
                font-size: 15px;
                padding: 18px;
            }
            
            .status {
                font-size: 16px;
                padding: 12px 24px;
            }
            
            #capturedImage {
                width: 180px;
                bottom: 140px;
            }
        }
        
        /* Enhanced landscape mode optimizations for Safari */
        @media (orientation: landscape) and (max-height: 500px) {
            .info {
                top: 5px;
                right: 5px;
                left: 5px;
                font-size: 11px;
                padding: 8px;
                max-width: 200px;
            }
            
            .status {
                top: 5px;
                font-size: 11px;
                padding: 6px 12px;
            }
            
            .controls {
                bottom: 15px; /* Increased for Safari landscape tab bar */
                padding: 8px 16px;
                padding-bottom: calc(15px + env(safe-area-inset-bottom, 10px));
                gap: 8px;
                margin-bottom: env(safe-area-inset-bottom, 0px);
            }
            
            .filter-btn {
                width: 40px;
                height: 40px;
                min-width: 40px;
                min-height: 40px;
                font-size: 16px;
                /* Ensure minimum 44px touch target even in landscape */
                padding: 2px;
            }
            
            .capture-btn {
                width: 50px;
                height: 50px;
                min-width: 50px;
                min-height: 50px;
            }
            
            #capturedImage {
                width: 80px;
                bottom: 80px; /* Increased to clear controls */
                right: 5px;
            }
            
            .camera-container {
                margin: 5px;
            }
        }
        
        /* Safari landscape specific adjustments */
        @supports (-webkit-touch-callout: none) {
            @media (orientation: landscape) and (max-height: 500px) {
                .controls {
                    bottom: 25px; /* Extra clearance for Safari landscape */
                    padding-bottom: calc(25px + env(safe-area-inset-bottom, 15px));
                    margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 5px);
                }
                
                #capturedImage {
                    bottom: 90px; /* Adjust for higher controls */
                }
            }
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="camera-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="overlay"></canvas>
            <div class="preview-flash"></div>
            <img id="capturedImage" alt="Captured photo">
        </div>
        
        <div class="status">
            <span id="statusText">Initializing camera...</span>
        </div>
        
        <div class="info">
            💡 <strong>Animated Filters + Extreme Morph!</strong><br>
            Interactive filters for children & pets + cartoon morph with massive eyes & huge mouth. Multi-face preview only. Photos save unfiltered.
        </div>
        
        <div class="controls">
            <div class="filter-selector">
                <button class="filter-btn active" data-filter="none">❌</button>
                <button class="filter-btn" data-filter="bouncing_balls">⚽</button>
                <button class="filter-btn" data-filter="twinkling_stars">⭐</button>
                <button class="filter-btn" data-filter="floating_hearts">💕</button>
                <button class="filter-btn" data-filter="pet_dots">🔴</button>
                <button class="filter-btn" data-filter="prey_fish">🐟</button>
                <button class="filter-btn" data-filter="sparkle_burst">✨</button>
                <button class="filter-btn" data-filter="face_morph">🎭</button>
            </div>
            <button class="capture-btn" id="captureBtn"></button>
        </div>
        
        <div class="loading" id="loading">Loading face detection model...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@0.0.3/dist/face-landmarks-detection.min.js"></script>
    <script>
        let video, overlay, ctx;
        let model;
        let currentFilter = 'none';
        let isCapturing = false;
        
        let animationTime = 0;
        let particles = [];
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        let isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || /iPhone|iPad|iPod/.test(navigator.userAgent);
        let performanceLevel = 'high'; // high, medium, low
        let adaptiveQuality = true;
        
        // Performance optimization variables
        let lastFaces = [];
        let facePositions = [];
        let skipFrameCounter = 0;
        let dynamicSkipInterval = 1;
        let cachedFaces = null;
        let faceMovementThreshold = 10;
        let consecutiveStableFrames = 0;
        let tensorsToDispose = [];
        let memoryPressureLevel = 0;
        
        // Pre-calculated math lookup tables
        const sinLookup = [];
        const cosLookup = [];
        const LOOKUP_SIZE = 360;
        for (let i = 0; i < LOOKUP_SIZE; i++) {
            const rad = (i * Math.PI * 2) / LOOKUP_SIZE;
            sinLookup[i] = Math.sin(rad);
            cosLookup[i] = Math.cos(rad);
        }
        
        // Canvas optimization variables
        let lastCanvasWidth = 0;
        let lastCanvasHeight = 0;
        let dirtyRegions = [];
        let offscreenCanvas = null;
        let offscreenCtx = null;
        
        // Web Worker variables
        let useWebWorker = false;
        let detectionWorker = null;
        let workerBusy = false;
        let pendingDetection = false;
        
        // Face morph variables
        let morphCanvas = null;
        let morphCtx = null;
        let morphImageData = null;
        let faceMorph = null;
        
        // Browser compatibility polyfills
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window.webkitRequestAnimationFrame || 
                                          window.mozRequestAnimationFrame || 
                                          window.oRequestAnimationFrame || 
                                          window.msRequestAnimationFrame ||
                                          function(callback) {
                                              return window.setTimeout(callback, 1000 / 60);
                                          };
        }
        
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = window.webkitCancelAnimationFrame || 
                                         window.mozCancelAnimationFrame || 
                                         window.oCancelAnimationFrame || 
                                         window.msCancelAnimationFrame ||
                                         function(id) {
                                             clearTimeout(id);
                                         };
        }
        
        // Performance API polyfill
        if (!window.performance) {
            window.performance = {
                now: function() {
                    return Date.now();
                }
            };
        } else if (!window.performance.now) {
            window.performance.now = function() {
                return Date.now();
            };
        }
        
        // Memory management functions
        function manageTensorMemory() {
            const memInfo = tf.memory();
            memoryPressureLevel = memInfo.numTensors > 50 ? 2 : (memInfo.numTensors > 25 ? 1 : 0);
            
            if (memoryPressureLevel > 0) {
                // Dispose accumulated tensors
                tensorsToDispose.forEach(tensor => {
                    if (tensor && !tensor.isDisposed) {
                        tensor.dispose();
                    }
                });
                tensorsToDispose = [];
                
                // Force garbage collection on high pressure
                if (memoryPressureLevel > 1) {
                    tf.disposeVariables();
                    if (tf.engine) {
                        tf.engine().startScope();
                        tf.engine().endScope();
                    }
                }
            }
        }
        
        // Face tracking and prediction functions
        function calculateFaceMovement(newFaces, oldFaces) {
            if (!oldFaces.length || !newFaces.length) return Infinity;
            
            let totalMovement = 0;
            let pairCount = 0;
            
            for (let i = 0; i < Math.min(newFaces.length, oldFaces.length); i++) {
                const newPoints = getFacePoints(newFaces[i]);
                const oldPoints = getFacePoints(oldFaces[i]);
                
                const centerMovement = Math.sqrt(
                    Math.pow(newPoints.noseTip[0] - oldPoints.noseTip[0], 2) +
                    Math.pow(newPoints.noseTip[1] - oldPoints.noseTip[1], 2)
                );
                
                totalMovement += centerMovement;
                pairCount++;
            }
            
            return pairCount > 0 ? totalMovement / pairCount : Infinity;
        }
        
        function interpolateFaces(faces, progress) {
            if (!cachedFaces || !faces.length) return faces;
            
            return faces.map((face, index) => {
                if (index >= cachedFaces.length) return face;
                
                const cached = cachedFaces[index];
                const current = face;
                
                // Simple interpolation for smooth animation
                const interpolated = {
                    ...current,
                    scaledMesh: current.scaledMesh.map((point, pointIndex) => {
                        if (pointIndex >= cached.scaledMesh.length) return point;
                        const cachedPoint = cached.scaledMesh[pointIndex];
                        return [
                            cachedPoint[0] + (point[0] - cachedPoint[0]) * progress,
                            cachedPoint[1] + (point[1] - cachedPoint[1]) * progress,
                            cachedPoint[2] + (point[2] - cachedPoint[2]) * progress
                        ];
                    })
                };
                
                return interpolated;
            });
        }
        
        // Optimized math functions using lookup tables
        function fastSin(angle) {
            const index = Math.floor(((angle % (Math.PI * 2)) / (Math.PI * 2)) * LOOKUP_SIZE);
            return sinLookup[Math.max(0, Math.min(LOOKUP_SIZE - 1, index))];
        }
        
        function fastCos(angle) {
            const index = Math.floor(((angle % (Math.PI * 2)) / (Math.PI * 2)) * LOOKUP_SIZE);
            return cosLookup[Math.max(0, Math.min(LOOKUP_SIZE - 1, index))];
        }
        
        // Canvas optimization functions
        function initOffscreenCanvas() {
            if (!offscreenCanvas) {
                offscreenCanvas = document.createElement('canvas');
                offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: false });
            }
        }
        
        function isInViewport(x, y, radius, canvasWidth, canvasHeight) {
            return x + radius >= 0 && x - radius <= canvasWidth && 
                   y + radius >= 0 && y - radius <= canvasHeight;
        }
        
        function shouldCullAnimation(face, canvasWidth, canvasHeight) {
            const points = getFacePoints(face);
            const { faceWidth } = getFaceDimensions(points);
            const maxRadius = faceWidth * 0.8; // Maximum possible filter radius
            
            // Check if any part of the face area is visible
            return !isInViewport(points.noseTip[0], points.noseTip[1], maxRadius, canvasWidth, canvasHeight);
        }
        
        // Web Worker support functions
        function initWebWorker() {
            if (typeof Worker === 'undefined' || isSafari) {
                console.log('Web Workers not supported or disabled for Safari');
                return false;
            }
            
            try {
                // For now, we'll use a simple fallback approach since creating a separate worker file
                // would require additional setup. In a production environment, you'd create a separate worker file.
                console.log('Web Worker support detected but using main thread for compatibility');
                return false;
            } catch (error) {
                console.warn('Failed to initialize Web Worker:', error);
                return false;
            }
        }
        
        async function detectFacesWithWorker(videoData) {
            // Placeholder for worker-based detection
            // In a full implementation, this would send video data to worker
            // and receive face detection results asynchronously
            return null;
        }
        
        // Face Morphing System
        class FaceMorph {
            constructor() {
                this.intensity = 1.0;
                this.eyeScaleFactor = 2.5;    // 150% larger eyes (extreme)
                this.faceSlimFactor = 0.85;   // 15% slimmer face
                this.jawReductionFactor = 0.9; // 10% smaller jaw
                this.mouthScaleFactor = 2.2;  // 120% larger mouth (extreme)
            }
            
            // Get key morphing landmarks from MediaPipe face mesh
            getMorphingLandmarks(face) {
                const mesh = face.scaledMesh;
                return {
                    // Eye regions
                    leftEyeCenter: mesh[468] || mesh[33],  // Fallback to outline point
                    rightEyeCenter: mesh[473] || mesh[263],
                    leftEyeTop: mesh[159],
                    leftEyeBottom: mesh[145],
                    leftEyeInner: mesh[133],
                    leftEyeOuter: mesh[33],
                    rightEyeTop: mesh[386],
                    rightEyeBottom: mesh[374],
                    rightEyeInner: mesh[362],
                    rightEyeOuter: mesh[263],
                    
                    // Face outline for slimming
                    faceLeft: mesh[172],
                    faceRight: mesh[397],
                    chinTip: mesh[175],
                    foreheadCenter: mesh[9],
                    
                    // Nose for reference
                    noseTip: mesh[1],
                    
                    // Jaw line for reduction
                    leftJaw: mesh[172],
                    rightJaw: mesh[397],
                    jawCenter: mesh[175],
                    
                    // Mouth landmarks for enlargement
                    mouthLeftCorner: mesh[61],
                    mouthRightCorner: mesh[291],
                    mouthTopCenter: mesh[13],
                    mouthBottomCenter: mesh[17],
                    upperLipTop: mesh[12],
                    lowerLipBottom: mesh[15],
                    mouthCenter: null // Will be calculated
                };
                
                // Calculate mouth center from corners
                if (landmarks.mouthLeftCorner && landmarks.mouthRightCorner) {
                    landmarks.mouthCenter = [
                        (landmarks.mouthLeftCorner[0] + landmarks.mouthRightCorner[0]) / 2,
                        (landmarks.mouthLeftCorner[1] + landmarks.mouthRightCorner[1]) / 2
                    ];
                }
                
                return landmarks;
            }
            
            // Calculate inverse transformation for proper warping (reverse mapping)
            inverseTransformPoint(x, y, landmarks, canvasWidth, canvasHeight) {
                let newX = x;
                let newY = y;
                
                // Reverse face slimming (horizontal expansion from center)
                const faceCenter = (landmarks.faceLeft[0] + landmarks.faceRight[0]) / 2;
                const faceInfluence = this.calculateFaceSlimInfluence(x, y, landmarks);
                
                if (faceInfluence > 0) {
                    const compressionFactor = 1 - (1 - this.faceSlimFactor) * faceInfluence * this.intensity;
                    const expansionFactor = 1 / compressionFactor;
                    newX = faceCenter + (newX - faceCenter) * expansionFactor;
                }
                
                // Reverse eye enlargement (shrink from eye centers)
                const leftEyeInfluence = this.calculateEyeInfluence(x, y, landmarks.leftEyeCenter, landmarks);
                const rightEyeInfluence = this.calculateEyeInfluence(x, y, landmarks.rightEyeCenter, landmarks);
                
                if (leftEyeInfluence > 0) {
                    const scale = 1 + (this.eyeScaleFactor - 1) * leftEyeInfluence * this.intensity;
                    const shrinkFactor = 1 / scale;
                    const centerX = landmarks.leftEyeCenter[0];
                    const centerY = landmarks.leftEyeCenter[1];
                    newX = centerX + (newX - centerX) * shrinkFactor;
                    newY = centerY + (newY - centerY) * shrinkFactor;
                }
                
                if (rightEyeInfluence > 0) {
                    const scale = 1 + (this.eyeScaleFactor - 1) * rightEyeInfluence * this.intensity;
                    const shrinkFactor = 1 / scale;
                    const centerX = landmarks.rightEyeCenter[0];
                    const centerY = landmarks.rightEyeCenter[1];
                    newX = centerX + (newX - centerX) * shrinkFactor;
                    newY = centerY + (newY - centerY) * shrinkFactor;
                }
                
                // Reverse mouth enlargement (shrink from mouth center)
                const mouthInfluence = this.calculateMouthInfluence(x, y, landmarks.mouthCenter, landmarks);
                
                if (mouthInfluence > 0) {
                    const scale = 1 + (this.mouthScaleFactor - 1) * mouthInfluence * this.intensity;
                    const shrinkFactor = 1 / scale;
                    const centerX = landmarks.mouthCenter[0];
                    const centerY = landmarks.mouthCenter[1];
                    newX = centerX + (newX - centerX) * shrinkFactor;
                    newY = centerY + (newY - centerY) * shrinkFactor;
                }
                
                return [newX, newY];
            }
            
            // Calculate transformation for a single point
            transformPoint(x, y, landmarks, canvasWidth, canvasHeight) {
                let newX = x;
                let newY = y;
                
                // Eye enlargement
                const leftEyeInfluence = this.calculateEyeInfluence(x, y, landmarks.leftEyeCenter, landmarks);
                const rightEyeInfluence = this.calculateEyeInfluence(x, y, landmarks.rightEyeCenter, landmarks);
                
                if (leftEyeInfluence > 0) {
                    const scale = 1 + (this.eyeScaleFactor - 1) * leftEyeInfluence * this.intensity;
                    const centerX = landmarks.leftEyeCenter[0];
                    const centerY = landmarks.leftEyeCenter[1];
                    newX = centerX + (x - centerX) * scale;
                    newY = centerY + (y - centerY) * scale;
                }
                
                if (rightEyeInfluence > 0) {
                    const scale = 1 + (this.eyeScaleFactor - 1) * rightEyeInfluence * this.intensity;
                    const centerX = landmarks.rightEyeCenter[0];
                    const centerY = landmarks.rightEyeCenter[1];
                    newX = centerX + (x - centerX) * scale;
                    newY = centerY + (y - centerY) * scale;
                }
                
                // Mouth enlargement
                const mouthInfluence = this.calculateMouthInfluence(x, y, landmarks.mouthCenter, landmarks);
                
                if (mouthInfluence > 0) {
                    const scale = 1 + (this.mouthScaleFactor - 1) * mouthInfluence * this.intensity;
                    const centerX = landmarks.mouthCenter[0];
                    const centerY = landmarks.mouthCenter[1];
                    newX = centerX + (newX - centerX) * scale;
                    newY = centerY + (newY - centerY) * scale;
                }
                
                // Face slimming (horizontal compression toward center)
                const faceCenter = (landmarks.faceLeft[0] + landmarks.faceRight[0]) / 2;
                const faceInfluence = this.calculateFaceSlimInfluence(x, y, landmarks);
                
                if (faceInfluence > 0) {
                    const compressionFactor = 1 - (1 - this.faceSlimFactor) * faceInfluence * this.intensity;
                    newX = faceCenter + (newX - faceCenter) * compressionFactor;
                }
                
                return [newX, newY];
            }
            
            // Calculate influence of eye enlargement at a point (enhanced for extreme scaling)
            calculateEyeInfluence(x, y, eyeCenter, landmarks) {
                if (!eyeCenter) return 0;
                
                const distance = Math.sqrt(
                    Math.pow(x - eyeCenter[0], 2) + Math.pow(y - eyeCenter[1], 2)
                );
                
                // Larger eye region radius for extreme scaling - extended influence zone
                const baseEyeRadius = Math.abs(landmarks.leftEyeOuter[0] - landmarks.leftEyeInner[0]) * 1.2;
                const eyeRadius = baseEyeRadius * (this.eyeScaleFactor > 2.0 ? 1.3 : 1.0);
                
                if (distance > eyeRadius) return 0;
                
                // Enhanced smooth falloff for extreme transformations
                const normalizedDistance = distance / eyeRadius;
                // Use a gentler falloff for larger transformations to avoid harsh edges
                const falloff = this.eyeScaleFactor > 2.0 ? 
                    Math.pow(Math.cos(normalizedDistance * Math.PI / 2), 0.7) :
                    Math.cos(normalizedDistance * Math.PI / 2);
                
                return falloff;
            }
            
            // Calculate influence of face slimming at a point
            calculateFaceSlimInfluence(x, y, landmarks) {
                const faceWidth = Math.abs(landmarks.faceRight[0] - landmarks.faceLeft[0]);
                const faceHeight = Math.abs(landmarks.foreheadCenter[1] - landmarks.chinTip[1]);
                const faceCenter = (landmarks.faceLeft[0] + landmarks.faceRight[0]) / 2;
                const faceCenterY = (landmarks.foreheadCenter[1] + landmarks.chinTip[1]) / 2;
                
                // Check if point is within face region
                const distanceFromCenterX = Math.abs(x - faceCenter);
                const distanceFromCenterY = Math.abs(y - faceCenterY);
                
                if (distanceFromCenterX > faceWidth * 0.6 || distanceFromCenterY > faceHeight * 0.6) {
                    return 0;
                }
                
                // Stronger influence on the sides of the face
                const horizontalInfluence = Math.max(0, 1 - (distanceFromCenterX / (faceWidth * 0.3)));
                const verticalInfluence = Math.max(0, 1 - (distanceFromCenterY / (faceHeight * 0.6)));
                
                return horizontalInfluence * verticalInfluence * 0.8; // Reduce overall intensity
            }
            
            // Calculate influence of mouth enlargement at a point (enhanced for extreme scaling)
            calculateMouthInfluence(x, y, mouthCenter, landmarks) {
                if (!mouthCenter || !landmarks.mouthLeftCorner || !landmarks.mouthRightCorner) return 0;
                
                const distance = Math.sqrt(
                    Math.pow(x - mouthCenter[0], 2) + Math.pow(y - mouthCenter[1], 2)
                );
                
                // Estimate mouth region radius from corners and vertical extent
                const mouthWidth = Math.abs(landmarks.mouthRightCorner[0] - landmarks.mouthLeftCorner[0]);
                const mouthHeight = landmarks.mouthBottomCenter && landmarks.mouthTopCenter ? 
                    Math.abs(landmarks.mouthBottomCenter[1] - landmarks.mouthTopCenter[1]) : mouthWidth * 0.3;
                
                // Expanded elliptical influence region for extreme scaling
                const scaleMultiplier = this.mouthScaleFactor > 1.8 ? 1.4 : 1.0;
                const mouthRadiusX = mouthWidth * 0.9 * scaleMultiplier;
                const mouthRadiusY = Math.max(mouthHeight * 1.5, mouthWidth * 0.5) * scaleMultiplier;
                
                // Calculate elliptical distance
                const normalizedX = (x - mouthCenter[0]) / mouthRadiusX;
                const normalizedY = (y - mouthCenter[1]) / mouthRadiusY;
                const ellipticalDistance = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
                
                if (ellipticalDistance > 1.0) return 0;
                
                // Enhanced smooth falloff for extreme transformations
                const falloff = this.mouthScaleFactor > 1.8 ? 
                    Math.pow(Math.cos(ellipticalDistance * Math.PI / 2), 0.6) :
                    Math.cos(ellipticalDistance * Math.PI / 2);
                
                return falloff;
            }
        }
        
        // Initialize morphing canvas
        function initMorphCanvas() {
            if (!morphCanvas) {
                morphCanvas = document.createElement('canvas');
                morphCtx = morphCanvas.getContext('2d', { willReadFrequently: true });
            }
        }
        
        // Apply face morphing to video frame
        function applyFaceMorph(ctx, face) {
            if (!faceMorph) return;
            
            // Adjust morphing intensity based on performance
            const quality = getQualitySettings();
            switch (performanceLevel) {
                case 'low':
                    faceMorph.intensity = 0.8;
                    faceMorph.eyeScaleFactor = 1.6;    // 60% larger eyes (moderate extreme)
                    faceMorph.mouthScaleFactor = 1.4;  // 40% larger mouth
                    faceMorph.faceSlimFactor = 0.9;
                    break;
                case 'medium':
                    faceMorph.intensity = 0.9;
                    faceMorph.eyeScaleFactor = 2.0;    // 100% larger eyes (high extreme)
                    faceMorph.mouthScaleFactor = 1.8;  // 80% larger mouth
                    faceMorph.faceSlimFactor = 0.88;
                    break;
                case 'high':
                default:
                    faceMorph.intensity = 1.0;
                    faceMorph.eyeScaleFactor = 2.5;    // 150% larger eyes (maximum extreme)
                    faceMorph.mouthScaleFactor = 2.2;  // 120% larger mouth
                    faceMorph.faceSlimFactor = 0.85;
                    break;
            }
            
            // Initialize morph canvas if needed
            initMorphCanvas();
            
            const canvasWidth = ctx.canvas.width;
            const canvasHeight = ctx.canvas.height;
            
            // Set morph canvas size to match main canvas
            if (morphCanvas.width !== canvasWidth || morphCanvas.height !== canvasHeight) {
                morphCanvas.width = canvasWidth;
                morphCanvas.height = canvasHeight;
            }
            
            // Get morphing landmarks
            const landmarks = faceMorph.getMorphingLandmarks(face);
            
            // Calculate face bounding box for optimization
            const points = getFacePoints(face);
            const { faceWidth, faceHeight, eyeCenter } = getFaceDimensions(points);
            
            // Create expanded bounding box for extreme transformations
            // Much larger padding needed for massive eye/mouth scaling
            const paddingMultiplier = performanceLevel === 'low' ? 0.4 : (performanceLevel === 'medium' ? 0.6 : 0.8);
            const faceMultiplier = performanceLevel === 'low' ? 0.8 : (performanceLevel === 'medium' ? 1.0 : 1.2);
            const heightMultiplier = performanceLevel === 'low' ? 0.9 : (performanceLevel === 'medium' ? 1.1 : 1.3);
            
            const padding = Math.max(faceWidth, faceHeight) * paddingMultiplier;
            const minX = Math.max(0, Math.floor(eyeCenter[0] - faceWidth * faceMultiplier - padding));
            const maxX = Math.min(canvasWidth, Math.ceil(eyeCenter[0] + faceWidth * faceMultiplier + padding));
            const minY = Math.max(0, Math.floor(eyeCenter[1] - faceHeight * heightMultiplier - padding));
            const maxY = Math.min(canvasHeight, Math.ceil(eyeCenter[1] + faceHeight * heightMultiplier + padding));
            
            const regionWidth = maxX - minX;
            const regionHeight = maxY - minY;
            
            if (regionWidth <= 0 || regionHeight <= 0) return;
            
            try {
                // Performance monitoring for morphing
                const morphStartTime = performance.now();
                
                // Get image data from video region
                const videoImageData = ctx.getImageData(minX, minY, regionWidth, regionHeight);
                const sourceData = videoImageData.data;
                
                // Create output image data
                const outputImageData = morphCtx.createImageData(regionWidth, regionHeight);
                const outputData = outputImageData.data;
                
                // Process pixels with morphing transformation
                for (let y = 0; y < regionHeight; y++) {
                    for (let x = 0; x < regionWidth; x++) {
                        const outputIndex = (y * regionWidth + x) * 4;
                        
                        // Calculate world coordinates
                        const worldX = minX + x;
                        const worldY = minY + y;
                        
                        // Apply inverse morphing transformation for proper warping
                        const [sourceX, sourceY] = faceMorph.inverseTransformPoint(worldX, worldY, landmarks, canvasWidth, canvasHeight);
                        
                        // Convert back to relative coordinates
                        const relativeSourceX = sourceX - minX;
                        const relativeSourceY = sourceY - minY;
                        
                        // Bilinear interpolation for smooth results
                        const sample = bilinearSample(sourceData, relativeSourceX, relativeSourceY, regionWidth, regionHeight);
                        
                        outputData[outputIndex] = sample[0];     // R
                        outputData[outputIndex + 1] = sample[1]; // G
                        outputData[outputIndex + 2] = sample[2]; // B
                        outputData[outputIndex + 3] = sample[3]; // A
                    }
                }
                
                // Put the morphed region back to canvas
                ctx.putImageData(outputImageData, minX, minY);
                
                // Enhanced performance monitoring for extreme mode
                const morphTime = performance.now() - morphStartTime;
                if (frameCount % 60 === 0) {
                    const extremeMode = faceMorph.eyeScaleFactor > 2.0 || faceMorph.mouthScaleFactor > 1.8;
                    console.log(`${extremeMode ? 'EXTREME' : 'Standard'} Morph: ${morphTime.toFixed(1)}ms, Region: ${regionWidth}x${regionHeight}, Eyes: ${faceMorph.eyeScaleFactor.toFixed(1)}x, Mouth: ${faceMorph.mouthScaleFactor.toFixed(1)}x`);
                    
                    // Auto-adjust if extreme mode is too slow
                    if (extremeMode && morphTime > 50 && performanceLevel !== 'low') {
                        console.warn('Extreme morph performance warning - consider reducing quality');
                    }
                }
                
            } catch (error) {
                console.warn('Morphing error:', error);
                // Continue without morphing if there's an error
            }
        }
        
        // Bilinear interpolation for smooth pixel sampling
        function bilinearSample(imageData, x, y, width, height) {
            // Clamp coordinates
            x = Math.max(0, Math.min(width - 1, x));
            y = Math.max(0, Math.min(height - 1, y));
            
            const x1 = Math.floor(x);
            const y1 = Math.floor(y);
            const x2 = Math.min(x1 + 1, width - 1);
            const y2 = Math.min(y1 + 1, height - 1);
            
            const fx = x - x1;
            const fy = y - y1;
            
            const getPixel = (px, py) => {
                const index = (py * width + px) * 4;
                return [
                    imageData[index] || 0,     // R
                    imageData[index + 1] || 0, // G
                    imageData[index + 2] || 0, // B
                    imageData[index + 3] || 255 // A
                ];
            };
            
            const p1 = getPixel(x1, y1);
            const p2 = getPixel(x2, y1);
            const p3 = getPixel(x1, y2);
            const p4 = getPixel(x2, y2);
            
            const result = [];
            for (let i = 0; i < 4; i++) {
                const top = p1[i] * (1 - fx) + p2[i] * fx;
                const bottom = p3[i] * (1 - fx) + p4[i] * fx;
                result[i] = Math.round(top * (1 - fy) + bottom * fy);
            }
            
            return result;
        }
        
        // Performance detection function with caching
        function detectPerformance() {
            // Check if we have cached performance data
            const cacheKey = 'faceFilterPerformance';
            const cached = localStorage.getItem(cacheKey);
            
            if (cached) {
                try {
                    const { level, timestamp, userAgent } = JSON.parse(cached);
                    // Cache is valid for 24 hours and same user agent
                    if (Date.now() - timestamp < 24 * 60 * 60 * 1000 && userAgent === navigator.userAgent) {
                        performanceLevel = level;
                        console.log(`Using cached performance level: ${performanceLevel}`);
                        return performanceLevel;
                    }
                } catch (e) {
                    // Invalid cache, continue with detection
                }
            }
            
            const startTime = performance.now();
            
            // Optimized performance test
            let testResult = 0;
            const iterations = isMobile ? 50000 : 100000; // Fewer iterations on mobile
            for (let i = 0; i < iterations; i++) {
                testResult += Math.random() * fastSin(i * 0.01);
            }
            
            const endTime = performance.now();
            const testDuration = endTime - startTime;
            
            // Adjust thresholds for mobile devices
            const highThreshold = isMobile ? 15 : 10;
            const mediumThreshold = isMobile ? 40 : 30;
            
            // Estimate performance level
            if (testDuration < highThreshold) {
                performanceLevel = 'high';
            } else if (testDuration < mediumThreshold) {
                performanceLevel = 'medium';
            } else {
                performanceLevel = 'low';
            }
            
            // Safari-specific adjustments for multi-face detection
            if (isSafari) {
                console.log('Safari detected - applying Safari-specific performance adjustments');
                
                // Safari typically needs more conservative settings for multi-face detection
                if (performanceLevel === 'high') {
                    performanceLevel = 'medium';
                    console.log('Safari: Reduced performance level from high to medium for stability');
                }
                
                // Check for older iOS devices which struggle with multi-face detection
                if (isIOS) {
                    const userAgent = navigator.userAgent;
                    const isOlderiOS = /OS [5-9]_|OS 10_|OS 11_/.test(userAgent);
                    
                    if (isOlderiOS || performanceLevel === 'medium') {
                        performanceLevel = 'low';
                        console.log('Safari iOS: Set to low performance for multi-face compatibility');
                    }
                }
            }
            
            // Additional mobile-specific adjustments
            if (isMobile && !isSafari) {
                if (performanceLevel === 'high') performanceLevel = 'medium';
            }
            
            // Cache the result
            try {
                localStorage.setItem(cacheKey, JSON.stringify({
                    level: performanceLevel,
                    timestamp: Date.now(),
                    userAgent: navigator.userAgent
                }));
            } catch (e) {
                // localStorage might not be available
                console.warn('Could not cache performance data:', e);
            }
            
            console.log(`Final performance level: ${performanceLevel} (Safari: ${isSafari}, iOS: ${isIOS})`);
            return performanceLevel;
        }
        
        // Adaptive quality settings
        function getQualitySettings() {
            const baseSettings = {
                'high': {
                    shadowBlur: 10,
                    animationSpeed: 1.0,
                    particleCount: 8,
                    detectionInterval: 1,
                    maxSkipFrames: 2,
                    memoryCleanupInterval: 60
                },
                'medium': {
                    shadowBlur: 6,
                    animationSpeed: 0.8,
                    particleCount: 5,
                    detectionInterval: 2,
                    maxSkipFrames: 3,
                    memoryCleanupInterval: 40
                },
                'low': {
                    shadowBlur: 3,
                    animationSpeed: 0.6,
                    particleCount: 3,
                    detectionInterval: 3,
                    maxSkipFrames: 5,
                    memoryCleanupInterval: 20
                }
            };
            
            const settings = baseSettings[performanceLevel] || baseSettings['high'];
            
            // Adjust settings based on memory pressure
            if (memoryPressureLevel > 0) {
                settings.detectionInterval = Math.min(settings.detectionInterval + memoryPressureLevel, 5);
                settings.particleCount = Math.max(settings.particleCount - memoryPressureLevel, 1);
                settings.shadowBlur = Math.max(settings.shadowBlur - memoryPressureLevel * 2, 1);
            }
            
            return settings;
        }
        
        const filterEffects = {
            bouncing_balls: {
                type: 'animated',
                name: 'Bouncing Balls',
                parts: [
                    { type: 'bouncing_ball', position: 'left_eye', color: '#FF6B6B', size: 0.3 },
                    { type: 'bouncing_ball', position: 'right_eye', color: '#4ECDC4', size: 0.3 },
                    { type: 'bouncing_ball', position: 'nose', color: '#45B7D1', size: 0.25 }
                ]
            },
            twinkling_stars: {
                type: 'animated',
                name: 'Twinkling Stars',
                parts: [
                    { type: 'twinkling_star', position: 'crown', color: '#FFD93D', size: 0.4 },
                    { type: 'twinkling_star', position: 'left_cheek', color: '#6BCF7F', size: 0.3 },
                    { type: 'twinkling_star', position: 'right_cheek', color: '#4D96FF', size: 0.3 }
                ]
            },
            floating_hearts: {
                type: 'animated',
                name: 'Floating Hearts',
                parts: [
                    { type: 'floating_heart', position: 'around_face', color: '#FF69B4', size: 0.2, count: 6 }
                ]
            },
            pet_dots: {
                type: 'animated',
                name: 'Moving Dots (Pet)',
                parts: [
                    { type: 'moving_dot', position: 'random_orbit', color: '#FF0000', size: 0.15, speed: 2 },
                    { type: 'moving_dot', position: 'random_orbit', color: '#00FF00', size: 0.12, speed: 1.5 },
                    { type: 'moving_dot', position: 'random_orbit', color: '#0000FF', size: 0.18, speed: 1.8 }
                ]
            },
            prey_fish: {
                type: 'animated',
                name: 'Swimming Fish (Pet)',
                parts: [
                    { type: 'swimming_fish', position: 'horizontal_swim', color: '#FF8C00', size: 0.3, speed: 1.2 },
                    { type: 'swimming_fish', position: 'horizontal_swim', color: '#32CD32', size: 0.25, speed: 0.8 }
                ]
            },
            sparkle_burst: {
                type: 'particle',
                name: 'Sparkle Burst',
                parts: [
                    { type: 'particle_burst', position: 'nose', particleType: 'sparkle', color: '#FFD700', count: 8 }
                ]
            },
            face_morph: {
                type: 'morph',
                name: 'Extreme Morph',
                description: 'Massive eyes + huge mouth + slim face cartoon filter'
            }
        };
        
        async function setupCamera() {
            video = document.getElementById('video');
            
            // Mobile-optimized camera constraints
            const constraints = {
                video: {
                    facingMode: 'user',
                    width: isMobile ? { ideal: 480, max: 640 } : { ideal: 640 },
                    height: isMobile ? { ideal: 360, max: 480 } : { ideal: 480 },
                    frameRate: isMobile ? { ideal: 24, max: 30 } : { ideal: 30 }
                }
            };
            
            // iOS Safari specific constraints
            if (isIOS) {
                constraints.video.width = { ideal: 320, max: 480 };
                constraints.video.height = { ideal: 240, max: 360 };
                constraints.video.frameRate = { ideal: 15, max: 24 };
            }
            
            try {
                // Try getUserMedia with polyfill for older browsers
                const getUserMedia = navigator.mediaDevices?.getUserMedia || 
                                   navigator.webkitGetUserMedia || 
                                   navigator.mozGetUserMedia || 
                                   navigator.msGetUserMedia;
                
                if (!getUserMedia) {
                    throw new Error('Camera access is not supported in this browser');
                }
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                video.srcObject = stream;
                
                // iOS Safari requires user interaction for video playback
                if (isIOS) {
                    video.muted = true;
                    video.playsInline = true;
                    video.setAttribute('playsinline', 'true');
                    video.setAttribute('muted', 'true');
                }
                
                return new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => {
                        // Ensure video is playing on iOS
                        if (isIOS && video.paused) {
                            video.play().catch(reject);
                        }
                        resolve();
                    };
                    
                    video.onerror = reject;
                    
                    // Timeout fallback
                    setTimeout(() => {
                        if (video.readyState === 0) {
                            reject(new Error('Video loading timeout'));
                        }
                    }, 10000);
                });
                
            } catch (error) {
                console.error('Camera setup error:', error);
                throw new Error(`Camera access failed: ${error.message}`);
            }
        }
        
        async function loadModel() {
            try {
                // Explicitly set the backend
                try {
                    await tf.setBackend('webgl');
                    console.log('Using WebGL backend');
                } catch (e) {
                    console.warn('WebGL is not supported, falling back to CPU');
                    await tf.setBackend('cpu');
                }

                // Wait for the backend to be ready
                await tf.ready();

                // Adjust model settings based on device performance
                const quality = getQualitySettings();
                let maxFaces;
                
                // Safari-specific face count adjustment
                if (isSafari) {
                    // Start with lower face count for Safari, increase based on performance
                    maxFaces = performanceLevel === 'low' ? 1 : 
                              (performanceLevel === 'medium' ? 2 : 3);
                    console.log(`Safari: Setting maxFaces to ${maxFaces} for performance level ${performanceLevel}`);
                } else {
                    maxFaces = performanceLevel === 'low' ? 1 : (performanceLevel === 'medium' ? 3 : 5);
                }
                
                // Safari-optimized model configuration
                const modelConfig = {
                    maxFaces: maxFaces,
                    refineLandmarks: !isSafari, // Disable refinement on Safari for better performance
                    detectionConfidence: isSafari ? 0.7 : 0.5, // Higher confidence threshold for Safari
                    maxContinuousChecks: isSafari ? 3 : 5, // Reduce continuous checks on Safari
                    detectorModelUrl: undefined, // Use default
                    landmarkModelUrl: undefined // Use default
                };
                
                console.log('Loading model with config:', modelConfig);
                
                model = await faceLandmarksDetection.load(
                    faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,
                    modelConfig
                );
                
                document.getElementById('loading').style.display = 'none';
                const optimizations = [
                    'frame-skipping',
                    'memory-mgmt',
                    'animation-culling',
                    'fast-math'
                ].join(' + ');
                
                const statusMessage = isSafari ? 
                    `Ready! Safari-optimized multi-face detection. Max faces: ${maxFaces}. Optimizations: ${optimizations}` :
                    `Ready! Multi-face filters active - preview only. Performance: ${performanceLevel}. Optimizations: ${optimizations}`;
                    
                document.getElementById('statusText').textContent = statusMessage;
                
                // Safari-specific memory management
                if (isSafari) {
                    // Force garbage collection periodically on Safari
                    setInterval(() => {
                        if (tf.memory().numTensors > 100) {
                            tf.disposeVariables();
                        }
                    }, 10000);
                }
                    
            } catch (error) {
                console.error('Model loading error:', error);
                document.getElementById('loading').style.display = 'none';
                
                // Safari-specific error handling
                if (isSafari && error.message.includes('backend')) {
                    document.getElementById('statusText').textContent = 
                        'Safari compatibility issue. Try enabling WebGL or use Chrome.';
                } else {
                    document.getElementById('statusText').textContent = 
                        'Error loading face detection model. Please refresh the page.';
                }
                throw error;
            }
        }
        
        function getFacePoints(face) {
            const mesh = face.scaledMesh;
            return {
                noseTip: mesh[1],
                leftEye: mesh[33],
                rightEye: mesh[263],
                foreheadCenter: mesh[9],
                leftMouth: mesh[61],
                rightMouth: mesh[291],
                leftCheek: mesh[116],
                rightCheek: mesh[345]
            };
        }
        
        function getFaceDimensions(points) {
            const faceWidth = Math.abs(points.rightEye[0] - points.leftEye[0]);
            const faceHeight = Math.abs(points.foreheadCenter[1] - points.noseTip[1]);
            const eyeCenter = [(points.leftEye[0] + points.rightEye[0]) / 2, (points.leftEye[1] + points.rightEye[1]) / 2];
            return { faceWidth, faceHeight, eyeCenter };
        }
        
        function drawBouncingBall(ctx, x, y, size, color, time) {
            const quality = getQualitySettings();
            const bounce = Math.abs(fastSin(time * 3 * quality.animationSpeed)) * 20;
            
            // Cull if outside viewport
            if (!isInViewport(x, y - bounce, size, ctx.canvas.width, ctx.canvas.height)) return;
            
            ctx.save();
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = quality.shadowBlur;
            ctx.beginPath();
            ctx.arc(x, y - bounce, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        function drawTwinklingStar(ctx, x, y, size, color, time) {
            const quality = getQualitySettings();
            const twinkle = 0.5 + 0.5 * fastSin(time * 4 * quality.animationSpeed);
            const points = 5;
            const outerRadius = size * twinkle;
            const innerRadius = size * 0.5 * twinkle;
            
            // Cull if outside viewport
            if (!isInViewport(x, y, outerRadius, ctx.canvas.width, ctx.canvas.height)) return;
            
            ctx.save();
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = quality.shadowBlur * twinkle;
            ctx.beginPath();
            ctx.translate(x, y);
            
            const rotation = time * 0.5 * quality.animationSpeed;
            const cosRot = fastCos(rotation);
            const sinRot = fastSin(rotation);
            
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / points;
                const tempX = fastCos(angle) * radius;
                const tempY = fastSin(angle) * radius;
                
                // Apply rotation manually for better performance
                const px = tempX * cosRot - tempY * sinRot;
                const py = tempX * sinRot + tempY * cosRot;
                
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        function drawFloatingHeart(ctx, x, y, size, color, time, offset) {
            const float = fastSin(time * 2 + offset) * 15;
            const scale = 0.8 + 0.2 * fastSin(time * 3 + offset);
            const heartSize = size * scale;
            const finalY = y + float;
            
            // Cull if outside viewport
            if (!isInViewport(x, finalY, heartSize * 30, ctx.canvas.width, ctx.canvas.height)) return;
            
            ctx.save();
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 8;
            ctx.translate(x, finalY);
            ctx.scale(heartSize, heartSize);
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(-0.5, -0.5, -1, -0.2, -0.5, 0.2);
            ctx.bezierCurveTo(0, 0.8, 0, 0.8, 0, 0.8);
            ctx.bezierCurveTo(0, 0.8, 0, 0.8, 0.5, 0.2);
            ctx.bezierCurveTo(1, -0.2, 0.5, -0.5, 0, 0);
            ctx.fill();
            ctx.restore();
        }
        
        function drawMovingDot(ctx, centerX, centerY, size, color, time, speed, faceWidth) {
            const radius = faceWidth * 0.6;
            const angle = time * speed;
            const x = centerX + fastCos(angle) * radius;
            const y = centerY + fastSin(angle) * radius * 0.7;
            
            // Cull if outside viewport
            if (!isInViewport(x, y, size, ctx.canvas.width, ctx.canvas.height)) return;
            
            ctx.save();
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        function drawSwimmingFish(ctx, x, y, size, color, time, speed, faceWidth) {
            const swimX = x + fastSin(time * speed) * faceWidth * 0.8;
            const swimY = y + fastCos(time * speed * 0.7) * 20;
            const fishSize = size * (0.8 + 0.2 * fastSin(time * 2));
            
            // Cull if outside viewport (fish is larger, so use bigger radius)
            if (!isInViewport(swimX, swimY, fishSize * 50, ctx.canvas.width, ctx.canvas.height)) return;
            
            ctx.save();
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.translate(swimX, swimY);
            ctx.scale(fishSize, fishSize);
            
            // Fish body
            ctx.beginPath();
            ctx.ellipse(0, 0, 30, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Fish tail
            ctx.beginPath();
            ctx.moveTo(-25, 0);
            ctx.lineTo(-40, -10);
            ctx.lineTo(-40, 10);
            ctx.closePath();
            ctx.fill();
            
            // Fish eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(10, -5, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawParticleBurst(ctx, x, y, time, color, count) {
            const quality = getQualitySettings();
            const actualCount = Math.min(count, quality.particleCount);
            
            // Cull entire burst if center is far outside viewport
            const maxDistance = 50; // Maximum particle distance from center
            if (!isInViewport(x, y, maxDistance, ctx.canvas.width, ctx.canvas.height)) return;
            
            ctx.save();
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = quality.shadowBlur;
            
            for (let i = 0; i < actualCount; i++) {
                const angle = (i / actualCount) * Math.PI * 2;
                const distance = 30 + fastSin(time * 3 * quality.animationSpeed) * 20;
                const px = x + fastCos(angle) * distance;
                const py = y + fastSin(angle) * distance;
                const sparkleSize = 3 + fastSin(time * 4 * quality.animationSpeed + i) * 2;
                
                // Individual particle culling
                if (isInViewport(px, py, sparkleSize, ctx.canvas.width, ctx.canvas.height)) {
                    ctx.beginPath();
                    ctx.arc(px, py, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }
        
        function drawFilter(ctx, face) {
            if (currentFilter === 'none' || !filterEffects[currentFilter]) return;
            
            // Cull entire face if outside viewport
            if (shouldCullAnimation(face, ctx.canvas.width, ctx.canvas.height)) return;
            
            const filter = filterEffects[currentFilter];
            
            // Handle morphing filter
            if (filter.type === 'morph') {
                applyFaceMorph(ctx, face);
                return;
            }
            
            // Handle other filter types
            const points = getFacePoints(face);
            const { faceWidth, faceHeight, eyeCenter } = getFaceDimensions(points);
            
            ctx.save();
            
            filter.parts.forEach((part, index) => {
                let x, y;
                
                switch (part.position) {
                    case 'left_eye':
                        x = points.leftEye[0];
                        y = points.leftEye[1];
                        break;
                    case 'right_eye':
                        x = points.rightEye[0];
                        y = points.rightEye[1];
                        break;
                    case 'nose':
                        x = points.noseTip[0];
                        y = points.noseTip[1];
                        break;
                    case 'crown':
                        x = eyeCenter[0];
                        y = points.foreheadCenter[1] - faceHeight * 0.5;
                        break;
                    case 'left_cheek':
                        x = points.leftCheek[0];
                        y = points.leftCheek[1];
                        break;
                    case 'right_cheek':
                        x = points.rightCheek[0];
                        y = points.rightCheek[1];
                        break;
                    case 'around_face':
                        // Multiple floating hearts
                        const heartPositions = [
                            [eyeCenter[0] - faceWidth * 0.6, eyeCenter[1] - faceHeight * 0.3],
                            [eyeCenter[0] + faceWidth * 0.6, eyeCenter[1] - faceHeight * 0.3],
                            [eyeCenter[0] - faceWidth * 0.8, eyeCenter[1] + faceHeight * 0.2],
                            [eyeCenter[0] + faceWidth * 0.8, eyeCenter[1] + faceHeight * 0.2],
                            [eyeCenter[0], eyeCenter[1] - faceHeight * 0.8],
                            [eyeCenter[0], eyeCenter[1] + faceHeight * 0.6]
                        ];
                        
                        heartPositions.forEach((pos, i) => {
                            drawFloatingHeart(ctx, pos[0], pos[1], faceWidth * part.size, part.color, animationTime, i);
                        });
                        return;
                    case 'random_orbit':
                        x = eyeCenter[0];
                        y = eyeCenter[1];
                        break;
                    case 'horizontal_swim':
                        x = eyeCenter[0];
                        y = eyeCenter[1] + (index * 40 - 20);
                        break;
                    default:
                        x = eyeCenter[0];
                        y = eyeCenter[1];
                }
                
                const size = faceWidth * part.size;
                
                switch (part.type) {
                    case 'bouncing_ball':
                        drawBouncingBall(ctx, x, y, size, part.color, animationTime);
                        break;
                    case 'twinkling_star':
                        drawTwinklingStar(ctx, x, y, size, part.color, animationTime);
                        break;
                    case 'moving_dot':
                        drawMovingDot(ctx, x, y, size, part.color, animationTime, part.speed, faceWidth);
                        break;
                    case 'swimming_fish':
                        drawSwimmingFish(ctx, x, y, part.size, part.color, animationTime, part.speed, faceWidth);
                        break;
                    case 'particle_burst':
                        drawParticleBurst(ctx, x, y, animationTime, part.color, part.count);
                        break;
                }
            });
            
            ctx.restore();
        }
        
        async function detectAndDraw() {
            if (!model || !video.videoWidth) return;
            
            try {
                const currentTime = performance.now();
                const deltaTime = currentTime - lastFrameTime;
                lastFrameTime = currentTime;
                
                // Calculate FPS and adjust performance
                frameCount++;
                if (frameCount % 30 === 0) {
                    fps = Math.round(1000 / deltaTime);
                    
                    // Dynamic performance adjustment
                    if (fps < 20) {
                        dynamicSkipInterval = Math.min(dynamicSkipInterval + 1, 5);
                        if (performanceLevel === 'high') performanceLevel = 'medium';
                        else if (performanceLevel === 'medium') performanceLevel = 'low';
                    } else if (fps > 28 && dynamicSkipInterval > 1) {
                        dynamicSkipInterval = Math.max(dynamicSkipInterval - 1, 1);
                    }
                }
                
                // Memory management
                const quality = getQualitySettings();
                if (frameCount % quality.memoryCleanupInterval === 0) {
                    manageTensorMemory();
                }
                
                // Adaptive animation speed
                const targetFPS = isSafari ? 24 : 30;
                const speedMultiplier = Math.min(1, targetFPS / Math.max(fps, 1));
                animationTime += (isSafari ? 0.04 : 0.05) * speedMultiplier;
                
                // Smart frame skipping strategy
                skipFrameCounter++;
                const effectiveSkipInterval = Math.max(quality.detectionInterval, dynamicSkipInterval);
                const shouldDetect = skipFrameCounter >= effectiveSkipInterval;
                
                let currentFaces = cachedFaces || [];
                
                if (shouldDetect) {
                    skipFrameCounter = 0;
                    
                    // Optimized detection options
                    const detectionOptions = { 
                        input: video,
                        returnTensors: false,
                        flipHorizontal: false
                    };
                    
                    const predictions = await model.estimateFaces(detectionOptions);
                    
                    if (predictions.length > 0) {
                        // Calculate face movement for adaptive skipping
                        const movement = calculateFaceMovement(predictions, lastFaces);
                        
                        if (movement < faceMovementThreshold) {
                            consecutiveStableFrames++;
                            // Increase skip interval for stable faces
                            if (consecutiveStableFrames > 10) {
                                dynamicSkipInterval = Math.min(dynamicSkipInterval + 1, quality.maxSkipFrames);
                            }
                        } else {
                            consecutiveStableFrames = 0;
                            dynamicSkipInterval = Math.max(dynamicSkipInterval - 1, 1);
                        }
                        
                        lastFaces = [...predictions];
                        cachedFaces = predictions;
                        currentFaces = predictions;
                    }
                } else if (cachedFaces) {
                    // Use interpolated faces for smooth animation
                    const progress = skipFrameCounter / effectiveSkipInterval;
                    currentFaces = interpolateFaces(cachedFaces, Math.min(progress, 1));
                }
                
                // Optimized rendering with canvas management
                if (overlay.width !== lastCanvasWidth || overlay.height !== lastCanvasHeight) {
                    lastCanvasWidth = overlay.width;
                    lastCanvasHeight = overlay.height;
                    initOffscreenCanvas();
                    if (offscreenCanvas) {
                        offscreenCanvas.width = overlay.width;
                        offscreenCanvas.height = overlay.height;
                    }
                }
                
                // Clear canvas
                ctx.clearRect(0, 0, overlay.width, overlay.height);
                
                if (currentFaces.length > 0 && !isCapturing) {
                    // For morphing filter, draw video frame first
                    if (currentFilter === 'face_morph') {
                        ctx.drawImage(video, 0, 0, overlay.width, overlay.height);
                    }
                    
                    // Process faces with performance considerations
                    if (isSafari) {
                        for (let i = 0; i < currentFaces.length; i++) {
                            drawFilter(ctx, currentFaces[i]);
                        }
                    } else {
                        currentFaces.forEach(face => {
                            drawFilter(ctx, face);
                        });
                    }
                }
                
                requestAnimationFrame(detectAndDraw);
                
            } catch (error) {
                console.error('Detection error:', error);
                
                // Error recovery with memory cleanup
                if (error.message.includes('memory') || error.message.includes('tensor')) {
                    console.warn('Memory error detected, performing cleanup');
                    manageTensorMemory();
                    if (performanceLevel !== 'low') {
                        performanceLevel = 'low';
                    }
                }
                
                requestAnimationFrame(detectAndDraw);
            }
        }
        
        function capturePhoto() {
            if (isCapturing) return;
            
            isCapturing = true;
            const flash = document.querySelector('.preview-flash');
            flash.classList.add('active');
            
            // Create a temporary canvas to capture the video frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw only the video frame (no filter)
            tempCtx.drawImage(video, 0, 0);
            
            // Convert to image
            tempCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const img = document.getElementById('capturedImage');
                img.src = url;
                img.classList.add('show');
                
                // Show notification
                document.getElementById('statusText').textContent = 
                    '✅ Photo saved without filters! (Preview still shows filters)';
                
                setTimeout(() => {
                    flash.classList.remove('active');
                    isCapturing = false;
                    
                    // Hide captured image after 3 seconds
                    setTimeout(() => {
                        img.classList.remove('show');
                        document.getElementById('statusText').textContent = 
                            'Ready! Multi-face filters active - preview only.';
                    }, 3000);
                }, 300);
            });
        }
        
        // Orientation change handler
        function handleOrientationChange() {
            setTimeout(() => {
                if (video && overlay) {
                    overlay.width = video.videoWidth;
                    overlay.height = video.videoHeight;
                    
                    // Restart detection after orientation change
                    detectAndDraw();
                }
            }, 500);
        }
        
        // Safari viewport height management
        function handleSafariViewport() {
            if (isSafari || isIOS) {
                // Handle Safari's dynamic viewport
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                
                // Detect if Safari interface is visible (more robust detection)
                const screenHeight = window.screen.height;
                const windowHeight = window.innerHeight;
                const heightRatio = windowHeight / screenHeight;
                const isInterfaceVisible = heightRatio < 0.85; // More conservative threshold
                
                document.body.classList.toggle('safari-interface-visible', isInterfaceVisible);
                
                // Additional check for Safari tab bar specifically
                const hasTabBar = windowHeight < screenHeight - 100; // Tab bar typically ~49px + margins
                document.body.classList.toggle('safari-tab-bar-visible', hasTabBar);
                
                // Force controls repositioning after viewport change
                setTimeout(() => {
                    const controls = document.querySelector('.controls');
                    if (controls) {
                        controls.style.transform = 'translateX(-50%) translateZ(0)'; // Force repaint
                        
                        // Ensure controls are always visible
                        const controlsRect = controls.getBoundingClientRect();
                        const viewportBottom = window.innerHeight;
                        
                        if (controlsRect.bottom > viewportBottom - 10) {
                            // Controls are too close to bottom, add emergency spacing
                            controls.style.bottom = '60px';
                            console.warn('Safari: Emergency control repositioning applied');
                        }
                    }
                }, 100);
            }
        }
        
        // Enhanced orientation change handler
        function handleOrientationChange() {
            setTimeout(() => {
                if (video && overlay) {
                    overlay.width = video.videoWidth;
                    overlay.height = video.videoHeight;
                    
                    // Safari viewport handling
                    handleSafariViewport();
                    
                    // Restart detection after orientation change
                    detectAndDraw();
                }
            }, 500);
        }
        
        // Add comprehensive event listeners for Safari
        window.addEventListener('orientationchange', handleOrientationChange);
        window.addEventListener('resize', handleSafariViewport);
        window.addEventListener('scroll', handleSafariViewport);
        
        // Initial Safari viewport setup
        if (isSafari || isIOS) {
            handleSafariViewport();
            
            // Handle Safari's initial load viewport issues
            window.addEventListener('load', () => {
                setTimeout(handleSafariViewport, 300);
            });
        }
        
        async function init() {
            try {
                // Safari diagnostic information
                if (isSafari) {
                    console.log('=== Safari Multi-Face Detection Diagnostics ===');
                    console.log('User Agent:', navigator.userAgent);
                    console.log('Is iOS:', isIOS);
                    console.log('TensorFlow.js version:', tf?.version || 'Not loaded');
                    console.log('Available backends:', tf?.getBackend ? tf.getBackend() : 'Unknown');
                }
                
                // Detect device performance first
                detectPerformance();
                
                // Initialize Web Worker if supported
                useWebWorker = initWebWorker();
                
                // Initialize Face Morph system
                faceMorph = new FaceMorph();
                
                await setupCamera();
                
                overlay = document.getElementById('overlay');
                overlay.width = video.videoWidth;
                overlay.height = video.videoHeight;
                ctx = overlay.getContext('2d', { willReadFrequently: true });
                
                // Safari-specific canvas optimizations
                if (isSafari) {
                    console.log('Applying Safari canvas optimizations');
                    ctx.imageSmoothingEnabled = false; // Disable smoothing for better performance
                    ctx.webkitImageSmoothingEnabled = false;
                }
                
                await loadModel();
                detectAndDraw();
                
                // Setup filter buttons with touch support
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    const handleFilterChange = (e) => {
                        e.preventDefault();
                        document.querySelectorAll('.filter-btn').forEach(b => 
                            b.classList.remove('active'));
                        btn.classList.add('active');
                        currentFilter = btn.dataset.filter;
                    };
                    
                    btn.addEventListener('click', handleFilterChange);
                    btn.addEventListener('touchend', handleFilterChange);
                    
                    // Add touch feedback
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        btn.style.transform = 'scale(0.95)';
                    });
                    
                    btn.addEventListener('touchend', () => {
                        btn.style.transform = '';
                    });
                    
                    btn.addEventListener('touchcancel', () => {
                        btn.style.transform = '';
                    });
                });
                
                // Setup capture button with touch support
                const captureBtn = document.getElementById('captureBtn');
                const handleCapture = (e) => {
                    e.preventDefault();
                    capturePhoto();
                };
                
                captureBtn.addEventListener('click', handleCapture);
                captureBtn.addEventListener('touchend', handleCapture);
                
                // Add touch feedback for capture button
                captureBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    captureBtn.style.transform = 'scale(0.95)';
                });
                
                captureBtn.addEventListener('touchend', () => {
                    captureBtn.style.transform = '';
                });
                
                captureBtn.addEventListener('touchcancel', () => {
                    captureBtn.style.transform = '';
                });
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loading').style.display = 'none';
                
                let errorMessage = 'Error: ';
                if (error.message.includes('Camera access failed')) {
                    errorMessage += 'Please allow camera access and refresh the page.';
                } else if (error.message.includes('not supported')) {
                    errorMessage += 'This browser does not support camera access.';
                } else {
                    errorMessage += error.message;
                }
                
                document.getElementById('statusText').textContent = errorMessage;
                
                // Show a user-friendly error in the info panel
                const infoPanel = document.querySelector('.info');
                if (infoPanel) {
                    infoPanel.innerHTML = `
                        <strong>⚠️ Error</strong><br>
                        ${errorMessage}<br>
                        <small>Try refreshing the page or using a different browser.</small>
                    `;
                    infoPanel.style.background = 'rgba(244, 67, 54, 0.9)';
                }
            }
        }
        
        init();
    </script>
</body>
</html>